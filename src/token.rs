//! We will partially follow the bittorrent implementation for issuing tokens
//! to nodes, the secret will change the every 10 minutes and tokens up to 10
//! minutes old will be accepted.
//!
//! This is in contrast with the bittorrent implementation,
//! where the secret will change every 5 minutes and tokens
//! up to 10 minutes old are accepted. Updating of the tokens that we have issued,
//! instead, store the secret and check if the token they gave us is valid for the
//! current or last secret.
//!
//! This is technically not what we want, but it will have essentially the same
//! result when we assume that nobody other than us knows the secret.
//!
//! With this scheme we can guarantee that the minimum amount of time a token
//! can be valid for is the maximum amount of time a token is valid for in bittorrent
//! in order to provide interop.
//!
//! Since we are not storing the tokens we generate (which is awesome)
//! we cant track how long each individual token has been checked out from
//! the store and so each token is valid for some time between 10 and 20 minutes in
//! contrast with 5 and 10 minutes.

use std::{
  net::{IpAddr, Ipv4Addr, Ipv6Addr},
  time::{Duration, Instant},
};

use crate::id::{Id, LengthError, ID_LEN};

const REFRESH_INTERVAL: Duration = Duration::from_secs(10 * 60);

const IPV4_SECRET_BUFFER_LEN: usize = 4 + 4;
const IPV6_SECRET_BUFFER_LEN: usize = 16 + 4;

/// In a Distributed Hash Table (DHT) network,
/// tokens are used to prevent Sybil attacks (are a type of attack on a network
/// where a single entity creates multiple fake identities to gain control of
/// the network or manipulate its behavior.) and ensure fairness in the network.
///
/// A Sybil attack is a type of attack where a single entity creates multiple
/// fake identities to gain control of a network.
/// In a DHT network, this can be prevented by requiring each node
/// to present a valid token before they can join the network.
///
/// The token is typically generated by a trusted third-party,
/// such as the DHT network's bootstrap nodes. When a node wants to join the network,
/// it requests a token from the bootstrap nodes.
/// The bootstrap nodes generate a unique token and send it back to the requesting node.
///
/// The token serves as proof that the node is legitimate and not a fake identity.
/// The node must present the token to other nodes in the network to prove that it has been authenticated.
///
/// In addition to preventing Sybil attacks, tokens also ensure fairness in the network.
/// Each node is typically given a limited number of tokens that they can use to join the network.
/// This prevents a single node from dominating the network by creating an unlimited number of fake identities.
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub struct Token {
  token: [u8; ID_LEN],
}

impl Token {
  pub fn new(bytes: &[u8]) -> Result<Self, LengthError> {
    Ok(Token {
      token: bytes.try_into().map_err(|_| LengthError)?,
    })
  }
}

impl From<Token> for [u8; ID_LEN] {
  fn from(token: Token) -> Self {
    token.token
  }
}

impl From<[u8; ID_LEN]> for Token {
  fn from(token: [u8; ID_LEN]) -> Self {
    Token { token }
  }
}

impl AsRef<[u8]> for Token {
  fn as_ref(&self) -> &[u8] {
    &self.token
  }
}

// -------------------------- //

/// Storing the Tokens in `DhtHandler`.
#[derive(Copy, Clone)]
pub struct TokenStore {
  // the current secret token.
  current_secret: u32,
  /// The secret from the previous time.
  /// - if we create the token, this would used as the backup token,
  ///   and this token may not timeout.
  /// 
  /// - if we refresh the token, this would also regarded as backup token,
  ///   to verify expired tokens in the future.
  last_secret: u32,
  /// Record the last we time refreshed the secret.
  last_refresh: Instant,
}

impl Default for TokenStore {
  fn default() -> Self {
    let current_secret = rand::random::<u32>();

    // We can just use a placeholder for the last secret as that would allow
    // external nodes to exploit recently started DHT. Instead, just generate
    // another placeholder secret for the last secret with the assumption that
    // we won't get a valid announce under the secret.
    // We could go the option route but that isn't as clean.
    let last_secret = rand::random::<u32>();

    let last_refresh = Instant::now();

    TokenStore {
      current_secret,
      last_secret,
      last_refresh,
    }
  }
}
impl TokenStore {
  pub fn check_out(&mut self, addr: IpAddr) -> Token {
    self.refresh_check();

    generate_token_from_addr(addr, self.current_secret)
  }
  pub fn check_in(&mut self, addr: IpAddr, token: Token) -> bool {
    self.refresh_check();

    // the token which is timeout would still work (at most one).
    validate_token_from_addr(addr, token, self.current_secret, self.last_secret)
  }

  fn refresh_check(&mut self) {
    // count the number of the interval: (current time - the last time refresh) / REFRESH_INTERVAL
    match intervals_passed(self.last_refresh) {
      // It's not update time yet.
      0 => (),
      1 => {
        self.last_secret = self.current_secret;
        self.current_secret = rand::random::<u32>();
        self.last_refresh = Instant::now();
      }
      _ => {
        self.last_secret = rand::random::<u32>();
        self.current_secret = rand::random::<u32>();
        self.last_refresh = Instant::now();
      }
    }
  }
}

/// Since we are lazily generating tokens, more than one interval could have passed
/// since we last generated a token in which case our last secret AND current
/// secret could invalid.
///
/// Returns the number of intervals have passed since the last refresh time.
fn intervals_passed(last_refresh: Instant) -> u64 {
  let current_time = Instant::now();
  let diff_time = current_time - last_refresh;

  diff_time.as_secs() / REFRESH_INTERVAL.as_secs()
}

/// Generate a token from an ip address and a secret.
fn generate_token_from_addr(addr: IpAddr, secret: u32) -> Token {
  match addr {
    IpAddr::V4(v4) => generate_token_from_addr_v4(v4, secret),
    IpAddr::V6(v6) => generate_token_from_addr_v6(v6, secret),
  }
}

/// Generate a token from an ipv4 and a secret.
///
/// The token for addr-v4 format:
/// ```
///        8 bytes
/// |  ip_v4  | secret |
///   4 bytes   4 bytes
/// ```
fn generate_token_from_addr_v4(v4_addr: Ipv4Addr, secret: u32) -> Token {
  let mut buffer = [0u8; IPV4_SECRET_BUFFER_LEN];
  let v4_bytes = v4_addr.octets();
  let secret_bytes = secret.to_be_bytes();

  let source_iter = v4_bytes.iter().chain(secret_bytes.iter());
  for (dst, src) in buffer.iter_mut().zip(source_iter) {
    *dst = *src;
  }

  let hash_buffer = Id::sha1(&buffer);
  Into::<[u8; ID_LEN]>::into(hash_buffer).into()
}

/// Generate a token from an ipv6 and a secret.
///
/// The token for addr-v6
/// ```
///     20 bytes
/// |   ip_v6   | secret |
///   16 bytes   4 bytes
/// ```
fn generate_token_from_addr_v6(v6_addr: Ipv6Addr, secret: u32) -> Token {
  let mut buffer = [0u8; IPV6_SECRET_BUFFER_LEN];
  let v6_bytes = v6_addr.octets();
  let secret_bytes = secret.to_be_bytes();

  let source_iter = v6_bytes.iter().chain(secret_bytes.iter());
  for (dst, src) in buffer.iter_mut().zip(source_iter) {
    *dst = *src;
  }

  let hash_buffer = Id::sha1(&buffer);
  Into::<[u8; ID_LEN]>::into(hash_buffer).into()
}

/// Verify the token with `current_secret` and the `last_secret`
fn validate_token_from_addr(
  addr: IpAddr,
  token: Token,
  current_secret: u32,
  last_secret: u32,
) -> bool {
  match addr {
    IpAddr::V4(v4) => {
      validate_token_from_addr_v4(v4, token, current_secret)
        || validate_token_from_addr_v4(v4, token, last_secret)
    }
    IpAddr::V6(v6) => {
      validate_token_from_addr_v6(v6, token, current_secret)
        || validate_token_from_addr_v6(v6, token, last_secret)
    }
  }
}

/// Validate a token given an ipv4 address and one secret.
fn validate_token_from_addr_v4(
  v4_addr: Ipv4Addr,
  token: Token,
  secret: u32,
) -> bool {
  generate_token_from_addr_v4(v4_addr, secret) == token
}

/// Validate a token given an ipv6 address and one secret.
fn validate_token_from_addr_v6(
  v6_addr: Ipv6Addr,
  token: Token,
  secret: u32,
) -> bool {
  generate_token_from_addr_v6(v6_addr, secret) == token
}

#[cfg(test)]
mod tests {
  use std::time::{Duration, Instant};

  use crate::test;
  use crate::token::TokenStore;

  #[test]
  fn positive_accept_valid_v4_token() {
    let mut store = TokenStore::default();
    let v4_addr = test::dummy_ipv4_addr();

    let valid_token = store.check_out(v4_addr);

    assert!(store.check_in(v4_addr, valid_token));
  }

  #[test]
  fn positive_accept_valid_v6_token() {
    let mut store = TokenStore::default();
    let v6_addr = test::dummy_ipv6_addr();

    let valid_token = store.check_out(v6_addr);

    assert!(store.check_in(v6_addr, valid_token));
  }

  #[test]
  fn positive_accept_v4_token_from_second_secret() {
    let mut store = TokenStore::default();
    let v4_addr = test::dummy_ipv4_addr();

    let valid_token = store.check_out(v4_addr);

    let past_offset = super::REFRESH_INTERVAL * 2 - Duration::from_secs(60);
    let past_time = Instant::now().checked_sub(past_offset).unwrap();
    store.last_refresh = past_time;

    assert!(store.check_in(v4_addr, valid_token));
  }

  #[test]
  fn positive_accept_v6_token_from_second_secret() {
    let mut store = TokenStore::default();
    let v6_addr = test::dummy_ipv6_addr();

    let valid_token = store.check_out(v6_addr);

    let past_offset = super::REFRESH_INTERVAL * 2 - Duration::from_secs(60);
    let past_time = Instant::now().checked_sub(past_offset).unwrap();
    store.last_refresh = past_time;

    assert!(store.check_in(v6_addr, valid_token));
  }

  #[test]
  #[should_panic]
  fn negative_reject_expired_v4_token() {
    let mut store = TokenStore::default();
    let v4_addr = test::dummy_ipv4_addr();

    let valid_token = store.check_out(v4_addr);

    let past_offset = super::REFRESH_INTERVAL * 2;
    let past_time = Instant::now().checked_sub(past_offset).unwrap();
    store.last_refresh = past_time;

    assert!(store.check_in(v4_addr, valid_token));
  }

  #[test]
  #[should_panic]
  fn negative_reject_expired_v6_token() {
    let mut store = TokenStore::default();
    let v6_addr = test::dummy_ipv6_addr();

    let valid_token = store.check_out(v6_addr);

    let past_offset = super::REFRESH_INTERVAL * 2;
    let past_time = Instant::now().checked_sub(past_offset).unwrap();
    store.last_refresh = past_time;

    assert!(store.check_in(v6_addr, valid_token));
  }
}
