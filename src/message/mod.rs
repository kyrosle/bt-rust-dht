//! Reference link: http://bittorrent.org/beps/bep_0005.html
//!
//! ## Contact Encoding
//! Contact information for `peers` is encoded as a `6-byte string`.
//! Also known as "Compact IP-address/port info" the 4-byte IP address
//! is in network byte order with the 2-byte port in network byte order concatenated onto the end.
//!
//! Contact information for `nodes` is encoded as a `26-byte string`.
//! Also known as "Compact node info" the 20-byte Node ID in network byte order
//! has the compact IP-address/port info concatenated to the end.

use std::fmt;

use serde::{Deserialize, Serialize};

pub mod error;
pub mod request;
pub mod response;
pub mod utils;

pub use error::*;
pub use request::*;
pub use response::*;
pub use utils::Want;
use utils::*;

/// DHT Queries: ping/find_node/get_peers/announce_peer
#[derive(Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct Message {
  /// Every message has a key "t" with a string value representing a transaction ID.
  ///
  /// This transaction ID is generated by the `querying node` and is echoed in the response,
  /// so responses may be correlated with multiple queries to the same node.
  ///
  /// The transaction ID should be encoded as a short string of binary numbers,
  /// `typically 2 characters` are enough as they cover 2^16 outstanding queries.
  #[serde(rename = "t", with = "serde_bytes")]
  pub transaction_id: Vec<u8>,
  #[serde(flatten)]
  pub body: MessageBody,
}

impl Message {
  /// Decode the message from bencode.
  ///
  /// `from_bytes_auto`:
  /// The same as from_bytes but deserialize_any will deserialize byte string as str
  /// if input bytes are valid UTF-8, otherwise as bytes.
  pub fn decode(input: &[u8]) -> Result<Self, serde_bencoded::DeError> {
    serde_bencoded::from_bytes_auto(input)
  }

  pub fn encode(&self) -> Vec<u8> {
    serde_bencoded::to_vec(self).expect("failed to serialize message")
  }
}

impl std::fmt::Debug for Message {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    f.debug_struct("Message")
      .field("transaction_id", &HexFmt(&self.transaction_id))
      .field("body", &self.body)
      .finish()
  }
}

struct HexFmt<'a>(&'a [u8]);

impl std::fmt::Debug for HexFmt<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    for b in self.0 {
      write!(f, "{:02x}", b)?
    }
    Ok(())
  }
}

/// Every message also has a key "y" with a single character value describing the type of message.
///
/// The value of the "y" key is one of "q" for query, "r" for response, or "e" for error.
///
/// A key "v" should be included in every message with a client version string.
/// (Not all implementations include a "v" key so clients should not assume its presence.)
#[derive(Clone, Eq, PartialEq, Serialize, Deserialize, Debug)]
#[serde(tag = "y")]
pub enum MessageBody {
  /// Queries, or KRPC message dictionaries with a "y" value of "q",
  /// contain two additional keys; "q" and "a".
  /// - Key "q" has a string value containing the method name of the query.
  /// - Key "a" has a dictionary value containing named arguments to the query.
  #[serde(rename = "q")]
  Request(Request),
  /// Responses, or KRPC message dictionaries with a "y" value of "r",
  /// contain one additional key "r".
  /// - The value of "r" is a dictionary containing named return values.
  /// - Response messages are sent upon successful completion of a query.
  #[serde(rename = "r", with = "unflatten::response")]
  Response(Response),
  /// Errors, or KRPC message dictionaries with a "y" value of "e",
  /// contain one additional key "e".
  /// - The value of "e" is a list.
  /// - The first element is an integer representing the error code.
  /// - The second element is a string containing the error message.
  ///
  /// Errors are sent when a query cannot be fulfilled.
  ///
  /// The following table describes the possible error codes [`error_code`]
  #[serde(rename = "e", with = "unflatten::error")]
  Error(Error),
}
